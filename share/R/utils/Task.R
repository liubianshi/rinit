# box 模块
box::use(R/utils/Logger[logger_factory])
box::use(R/utils/Cache[cache_result = result])
box::use(R/utils/Tool[ifthen, execute_box_mod_func])
box::use(utils[modifyList])
box::use(yaml[read_yaml, write_yaml])
box::use(tools[file_ext])
box::use(glue[glue])
box::use(fs[path_rel])
box::use(stats[setNames])
LOG <- logger_factory("Task")

# --- 1. 配置加载 ---

#' Load Application Configuration
#'
#' Checks for the existence of configuration files (`config.R` or `config.yml`)
#' and loads the settings. Prioritizes `config.R`.
load_config <- function() {
  # 优先加载 R 文件 (支持动态逻辑)
  if (file.exists("config.R")) {
    cfg <- tryCatch(
      source("config.R", local = TRUE, echo = FALSE)[["value"]],
      error = function(e) {
        LOG$warn(glue("Error sourcing config.R: {e$message}"))
        NULL
      }
    )
    if (!is.null(cfg)) return(cfg)
  }

  # 其次加载 YAML
  if (file.exists("config.yml")) {
    return(read_yaml("config.yml"))
  }

  LOG$warn("Config file not found (config.R or config.yml)")
  return(list())
}

# 模块加载时执行一次，避免重复 IO
CONFIG <- load_config()

# --- 2. 元数据处理核心逻辑 ---
#' Generate a Flattened List of Task Metadata
#'
#' Recursively traverses a nested configuration list to produce a flat list of
#' task definitions. A node is considered a task if it contains both `mod` and
#' `func` elements. Task names are generated by joining nested keys with a colon.
#'
#' @param meta_tree A list structure containing the configuration tree.
#'   Defaults to the global object `CONFIG`.
#' @param name A character string representing the current hierarchical path.
#'   Defaults to `NULL` for the root level.
#'
#' @return A named list where each element represents a task containing its
#'   hierarchical `name`, `mod`, `func`, and other metadata.
#' @export
generate_meta_list <- function(meta_tree = CONFIG, name = NULL) {
  if (!is.list(meta_tree)) {
    return(NULL)
  }

  # Check if the current node is a valid leaf (task definition)
  # We ensure 'name' is not NULL to avoid treating the root as a task
  if (all(c("mod", "func") %in% names(meta_tree))) {
    if (is.null(name)) {
      return(NULL)
    }
    meta <- c(list(name = name), meta_tree)
    return(setNames(list(meta), name))
  }

  # Determine hierarchical names for child nodes
  node_names <- names(meta_tree)
  child_names <- if (is.null(name)) {
    node_names
  } else {
    paste(name, node_names, sep = ":")
  }

  # Recursively process child nodes
  results <- mapply(
    generate_meta_list,
    meta_tree = meta_tree,
    name = child_names,
    SIMPLIFY = FALSE,
    USE.NAMES = FALSE
  )

  # Flatten the list one level to merge recursive results
  unlist(results, recursive = FALSE)
}

TASKS <- generate_meta_list()

#' Find the File Path of a Box Module
#'
#' Resolves the physical file path for a given module string (e.g., "utils.logger")
#' based on the `box` package search mechanism. It searches the current
#' working directory and paths defined in `getOption("box.path")`.
#'
#' @param mod_str A character string representing the module name.
#' @return A character string containing the normalized file path if found.
#' @importFrom glue glue
find_module_path <- function(mod_str) {
  # 1. Normalize module syntax to path syntax (replace . with /)
  rel_path <- chartr(".", "/", mod_str)

  # 2. Define search roots: current directory and box.path option
  # unique() avoids redundant checks if '.' is also in box.path
  search_roots <- unique(c(getwd(), getOption("box.path")))

  # 3. Define candidate filenames:
  # - Standard script module: path/to/mod.R
  # - Directory module: path/to/mod/__init__.R
  candidates <- c(paste0(rel_path, ".R"), file.path(rel_path, "__init__.R"))

  # 4. Iterate through roots to find the existing file
  for (root in search_roots) {
    # Construct potential full paths for this root
    check_paths <- file.path(root, candidates)

    # Identify which candidates exist
    existing_paths <- check_paths[file.exists(check_paths)]

    if (length(existing_paths) > 0) {
      # Return the first match found, normalized
      return(path_rel(existing_paths[1]))
    }
  }

  # 5. Error logging if module is not found
  LOG$error(glue("Module '{mod_str}' not found in search paths: {paste(search_roots, collapse = ', ')}"))
}

#' Generate Cache File Path from Metadata
#'
#' Creates a hierarchical directory structure based on task name and returns
#' the full path to a cache file. The function splits the task name by colons
#' to create nested directories and ensures the directory structure exists.
#'
generate_task_output_name <- function(meta) {
  # Validate required metadata
  if (is.null(meta$name) || !nzchar(meta$name)) {
    LOG$error("Task name is required and cannot be empty!")
  }

  # Parse hierarchical path from colon-separated task name
  path_components <- strsplit(meta$name, ":", fixed = TRUE)[[1]]
  target_dir <- do.call(file.path, as.list(path_components))

  # Determine cache filename with validation
  fname <- ifthen(meta$filename, "default.qs")
  if (file_ext(fname) == "") {
    fname <- paste0(fname, ".qs")
  }

  file.path(target_dir, fname)
}


# --- 3. 校验逻辑 ---

#' Validate Information Metadata
#'
#' Verifies that the provided metadata object is valid. It ensures all required
#' components ('name', 'mod', 'func', 'path') are present, non-null, and meet
#' specific criteria, such as file accessibility and correct file extensions.
#'
assert_metadata <- function(meta) {
  if (is.null(meta)) {
    LOG$error("Task metadata is NULL")
  }

  # 1. Validate 'name' (delegated to external function)
  if (!is.character(meta$name) || length(meta$name) != 1L) {
    LOG$error("Task 'name' must be a single string.")
  }

  # 正则允许字母、数字、下划线、短横线，以冒号分隔
  if (!grepl("^[-_A-Za-z0-9]+(:[-_A-Za-z0-9]+)+$", meta$name)) {
    LOG$error(glue("Invalid task name format: '{meta$name}'. Expected 'group:subgroup:task'"))
  }

  real_mod_path <- tryCatch(
    find_module_path(meta$mod),
    error = function(e) stop(glue("Task '{meta$name}': {e$message}"))
  )

  # Verify module file accessibility
  # Check current directory and box.path options
  mod_file <- paste0(meta$mod, ".R")
  search_paths <- c(".", getOption("box.path", default = character(0)))
  full_paths <- file.path(search_paths, mod_file)

  if (!any(file.exists(file.path(search_paths, mod_file)))) {
    LOG$error(glue("Task '{meta$name}': Module '{mod_file}' not found in search paths."))
  }

  # 3. Validate 'func' (Function Name)
  if (is.null(meta$func) || !nzchar(meta$func)) {
    LOG$error(glue("Task '{meta$name}': 'func' is missing"))
  }

  # 4. Validate 'path' (File Path)
  if (is.null(meta$path) || !nzchar(meta$path)) {
    LOG$error(glue("Task '{meta$name}': Output path is missing"))
  }
  if (tolower(file_ext(meta$path)) != "qs") {
    LOG$error(glue("Task '{meta$name}': Output file must end with .qs"))
  }

  return(TRUE)
}

# --- 4. 核心功能 ---

#' Fetch and Validate Task Metadata with Configuration Defaults
#'
#' This function retrieves task metadata by merging configuration defaults
#' with user-provided metadata. It validates inputs, constructs cache paths,
#' and ensures metadata completeness.
#'
#' @param name Character string specifying the task name. Can be NULL if
#'   `meta` contains a name field. Task names can be hierarchical using
#'   colon separators (e.g., "parent:child:task").
#' @param meta List containing task metadata. Can be NULL to use only
#'   configuration defaults. When provided, values override config defaults.
#'
#' @return A list containing the complete task metadata with all required
#'   fields populated. Returns `invisible(NULL)` if validation fails.
#'
#' @details
#' The function performs the following operations:
#' \itemize{
#'   \item Validates that at least one of `name` or `meta` is provided
#'   \item Resolves the task name from either parameter
#'   \item Loads configuration from "config.yml"
#'   \item Navigates nested config structure using colon-separated keys
#'   \item Merges config defaults with user-provided metadata
#'   \item Generates cache path if not specified
#'   \item Validates final metadata completeness
#' }
#'
#' @examples
#' \dontrun{
#' # Fetch metadata using task name only
#' meta <- fetch_task_meta_with(task = "data:processing:clean")
#'
#' # Override specific metadata fields
#' meta <- fetch_task_meta_with(
#'   task = "analysis:model",
#'   meta = list(version = "2.0", args = list(method = "lm"))
#' )
#' }
#'
#' @export
fetch_task_meta_with <- function(name = NULL, meta = NULL) {
  # 1. 从全局配置中提取基础配置
  base_meta <- list()
  if (!is.null(name)) {
    name <- trimws(name)
    if (!name %in% names(TASKS)) {
      LOG$error(glue("Task '{name}' is not defined in config."))
    }
    base_meta <- TASKS[[name]]
  }

  # 2. 合并传入的 meta (覆盖配置)
  final_meta <- modifyList(base_meta, meta %||% list())

  # 确保有名字 (如果只传了 meta 没传 name)
  if (is.null(final_meta$name) && !is.null(name)) {
    final_meta$name <- name
  }

  # 3. 生成输出路径
  if (is.null(final_meta$path)) {
    final_meta$path <- generate_task_output_name(final_meta)
  }

  # 4. 确保 args 存在
  final_meta$args <- ifthen(final_meta$args, list())

  # 5. 强校验 (失败直接 Stop)
  assert_metadata(final_meta)

  final_meta
}

#' Cache and Retrieve Task Results
#'
#' Executes a task defined in the configuration file and caches its result.
#' Supports hierarchical task definitions and automatic cache invalidation.
#'
#' @param name Character string specifying the task path (colon-separated hierarchy).
#' @param update Logical or expression to determine cache update behavior. Default is NULL.
#'
#' @return The cached result of the task execution, or NULL if an error occurs.
#' @export
#'
#' @examples
#' \dontrun{
#' cache_result("data:processing:clean")
#' cache_result("model:train", update = TRUE)
#' }
run_task <- function(name = NULL, meta = NULL) {
  # 获取并校验元数据 (如果有错误会直接在此处停止)
  task_meta <- fetch_task_meta_with(name, meta)

  LOG$info(glue("Starting task: {task_meta$name}"))

  # 准备目录 (Lazy creation: 只有真正运行时才创建目录)
  dir.create(dirname(task_meta$path), recursive = TRUE, showWarnings = FALSE)

  # Execute and cache function results with error handling
  tryCatch(
    {
      val <- cache_result(
        execute_box_mod_func(task_meta$mod, task_meta$func, task_meta$args),
        file = task_meta$path,
        update = task_meta$update
      )
      LOG$info(glue("Task '{task_meta$name}' completed. Cache: {task_meta$path}"))
      invisible(val)
    },
    error = function(e) {
      # 记录错误并向上抛出，确保 go-task 知道任务失败了
      LOG$error(glue("Task '{task_meta$name}' FAILED: {e$message}"))
      stop(e)
    }
  )
}

#' Write Tasks to a Category-Specific YAML File
#'
#' This function processes a list of tasks and writes them to a YAML file within a
#' "tasks" directory. It automatically handles directory creation, prepends a
#' timestamped warning header, and utilizes `gen_task_content` for formatting.
#'
#' @param tasks A list containing task objects. If `category` is `NULL`, this
#'   must be a named list, where the names serve as categories for recursive calls.
#' @param category A character string indicating the filename (without extension).
#'   If `NULL`, the function iterates over `tasks` using its names.
#'
#' @return Returns `NULL` invisibly. The function is called for its side effect
#'   of writing files to disk.
#' @export
write_taskfile <- function(taskfile_name = "r_tasks.yml") {
  if (length(TASKS) == 0) {
    LOG$warn("No tasks found to write.")
    return(invisible(NULL))
  }

  # 构造 Go-Task 格式的列表
  # 遍历 TASKS 列表
  go_tasks <- lapply(TASKS, function(meta) {
    # 在生成文件时做一次校验，如果有问题则跳过该任务
    tryCatch(
      {
        # 临时补全 path 做校验
        if (is.null(meta$path)) {
          meta$path <- generate_task_output_name(meta)
        }
        assert_metadata(meta)

        # 构造命令：Go-Task 会将 {{.TASK}} 替换为任务名
        cmd_str <- sprintf('Rscript -e \'box::use(R/utils/Task); Task$run_task("{{.TASK}}")\'')

        task <- modifyList(
          ifthen(meta$task, list()),
          list(
            desc = ifthen(meta$desc, glue("Run task: {meta$name}")),
            cmds = list(cmd_str), # go-task 使用 cmds 列表
          )
        )
        task$sources <- c(task$sources, find_module_path(meta$mod)) |> as.list()
        task$generates <- c(task$generates, meta$path) |> as.list()
        task
      },
      error = function(e) {
        LOG$warn(glue("Skipping invalid task '{meta$name}': {e$message}"))
        NULL
      }
    )
  })

  # 移除 NULL (跳过的任务)
  go_tasks <- Filter(Negate(is.null), go_tasks)

  # 写入文件
  # Prepare directory path
  output_dir <- "tasks"
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }
  output_file <- file.path(output_dir, taskfile_name)

  con <- file(output_file, open = "w", encoding = "UTF-8")
  on.exit(close(con), add = TRUE)

  writeLines(
    c(
      "# [WARNING] This file is automatically generated by a script. Do not modify it manually.",
      format(Sys.time(), "# Modified at: %Y-%m-%d %H:%M:%S"),
      "# https://taskfile.dev",
      "version: '3'",
      ""
    ),
    con
  )

  # 写入 tasks 节点
  write_yaml(list(tasks = go_tasks), file = con)

  LOG$info(glue("Taskfile generated at {output_file} ({length(go_tasks)} tasks)"))

  invisible(NULL)
}
