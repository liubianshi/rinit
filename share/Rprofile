# Project-level .Rprofile
# This file is executed when R starts in this project directory

# First, source user-level .Rprofile if it exists (to preserve user settings)
if (file.exists("~/.Rprofile")) {
  source("~/.Rprofile")
}

# General R options
options(
  stringsAsFactors = FALSE,
  max.print = 100,
  scipen = 10,
  width = 120,
  box.path = c(file.path(getwd(), "r-box"), getwd())
)

# Activate renv if available
if (file.exists("renv/activate.R")) {
  source("renv/activate.R")
}

# ENVIRONMENT VARIABLE
METADATA <- yaml::read_yaml("_metadata.yml")
CONFIG <- yaml::read_yaml("config.yml")
PROJECT_NAME <- METADATA$project_name
Sys.setenv(PROJECT_NAME = PROJECT_NAME)

cache_result <- function(task, update = NULL) {
  # Initialize logger
  box::use(utils/logger[logger_factory])
  logger <- logger_factory("cache")

  # Parse task path into hierarchical keys
  keys <- strsplit(task, ":", fixed = TRUE)[[1]]

  # Navigate CONFIG structure to retrieve metadata
  info <- Reduce(function(meta, key) meta[[key]], keys, init = CONFIG)

  # Validate metadata completeness
  if (is.null(info) || is.null(info$mod) || is.null(info$func)) {
    logger$error("Invalid or incomplete metadata for task: {task}")
    return(invisible(NULL))
  }

  # Construct cache file path
  target_path <- local({
    target_dir <- do.call(file.path, as.list(keys[-length(keys)]))

    # Ensure cache directory exists
    if (!dir.exists(target_dir)) {
      dir.create(target_dir, recursive = TRUE)
    }

    target_filename <- glue::glue("{keys[length(keys)]}.qs")
    file.path(target_dir, target_filename)
  })

  # Load caching utility
  box::use(utils/cache[cache_result = result])

  run <- function(mod, func, args) {
    # Dynamically load module and function
    tryCatch(
      {
        box_expr <- sprintf("box::use(%s[%s])", mod, func)
        eval(parse(text = box_expr), envir = parent.frame())
      },
      error = function(e) {
        logger$error("Failed to load module {mod}: {e$message}")
        return(invisible(NULL))
      }
    )

    # Retrieve and execute the loaded function
    func <- get(func, envir = parent.frame())

    if (!is.function(func)) {
      logger$error(glue::glue("`{func}` is not a function."))
      return(invisible(NULL))
    }

    do.call(func, args)
  }

  # Execute and cache function results with error handling
  result <- NULL
  tryCatch(
    {
      result <- cache_result(
        run(info$mod, info$func, lbs::ifthen(info$args, list())),
        target_path,
        lbs::ifthen(update, info$update)
      )

      logger$info("Task '{task}' cached successfully at '{target_path}'")
    },
    error = function(e) {
      logger$error("Caching failed for task '{task}': {e$message}")
    }
  )

  result
}

fetch_cached <- function(task) {
  cache_result(task, update = FALSE)
}

# Project startup message
packageStartupMessage(
  paste0("\n", "✓ Project loaded: ", PROJECT_NAME, "\n", "✓ Working directory: ", getwd(), "\n")
)
